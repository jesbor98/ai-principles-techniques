package NRow.Players;

import NRow.TreeNode;
import NRow.Board;
import NRow.Heuristics.Heuristic;
import NRow.Game;

public class MinMaxPlayer extends PlayerController {
    private int maxDepth;
    private int player2Id;

    public MinMaxPlayer(int playerId, int gameN, int maxDepth, Heuristic heuristic) {
        super(playerId, gameN, heuristic);
        this.maxDepth = maxDepth;
    }

    @Override
    public int makeMove(Board board) {
        TreeNode root = new TreeNode(board, -1);
        generateTree(root, maxDepth, playerId);
        int bestMove = 0;
        int bestValue = Integer.MIN_VALUE;

        for (TreeNode node : root.getChildren()) {
            this.player2Id = (playerId == 1) ? 2 : 1;
            int value = minimax(node, maxDepth - 1, player2Id, false);
            if (value > bestValue) {
                bestValue = value;
                bestMove = node.getMove();
            }
        }
        int validMove = findValidMove(board, bestMove);
        if (validMove != 0) {
            return validMove;
        } else {
            // Handle the case when no valid move is found (e.g., board is full)
            // You may want to return a special value or handle it as appropriate for your
            // game.
            return 0; // Or another suitable value or action
        }
    }

    public int findValidMove(Board board, int move) {
        if (board.isValid(move)) {
            return move; // Found a valid move
        } else {
            int nextMove = move + 1;
            if (nextMove >= board.width) {
                nextMove = 0; // Wrap around to the beginning
            }
            // Ensure that nextMove is within valid bounds
            if (nextMove < 0) {
                nextMove = 0; // Handle case where nextMove becomes negative
            }
            // Recursively try the next move
            return findValidMove(board, nextMove);
        }

    }

    private void generateTree(TreeNode node, int depth, int currentPlayer) {
        if (depth == 0 || Game.winning(node.getBoard().getBoardState(), gameN) != 0) {
            return;
        }

        for (int col = 0; col < node.getBoard().width; col++) {
            if (node.getBoard().isValid(col)) {
                Board newBoard = node.getBoard().getNewBoard(col, currentPlayer);
                TreeNode childNode = new TreeNode(newBoard, col);
                node.addChild(childNode);
                currentPlayer = (playerId == 1) ? 2 : 1;
                generateTree(childNode, depth - 1, currentPlayer);
            }
        }
    }

    private int minimax(TreeNode node, int depth, int currentPlayer, boolean isMaximizing) {
        if (depth == 0 || Game.winning(node.getBoard().getBoardState(), gameN) != 0) {
            return heuristic.evaluateBoard(this.playerId, node.getBoard(), gameN);
        }

        if (isMaximizing) {
            int maxEval = Integer.MIN_VALUE;
            for (TreeNode child : node.getChildren()) {
                currentPlayer = (playerId == 1) ? 2 : 1;
                int eval = minimax(child, depth - 1, currentPlayer, false);
                maxEval = Math.max(maxEval, eval);
            }
            return maxEval;
        } else {
            int minEval = Integer.MAX_VALUE;
            for (TreeNode child : node.getChildren()) {
                currentPlayer = (playerId == 1) ? 2 : 1;
                int eval = minimax(child, depth - 1, currentPlayer, true);
                minEval = Math.min(minEval, eval);
            }
            return minEval;
        }
    }
}

______________________________________________________________________________________

package NRow.Players;

import NRow.TreeNode;
import NRow.Board;
import NRow.Heuristics.Heuristic;
import NRow.Game;

public class AlphaBetaPlayer extends PlayerController {
    private int maxDepth;
    private int player2Id;

    public AlphaBetaPlayer(int playerId, int gameN, int maxDepth, Heuristic heuristic) {
        super(playerId, gameN, heuristic);
        this.maxDepth = maxDepth;
    }

    @Override
    public int makeMove(Board board) {
        TreeNode root = new TreeNode(board, -1);
        generateTree(root, maxDepth, playerId);
        int bestMove = 0;
        int bestValue = Integer.MIN_VALUE;
        int alpha = Integer.MIN_VALUE;
        int beta = Integer.MAX_VALUE;

        for (TreeNode node : root.getChildren()) {
            this.player2Id = (playerId == 1) ? 2 : 1;
            int value = alphabeta(node, maxDepth, playerId, alpha, beta, false);
            if (value > bestValue) {
                bestValue = value;
                bestMove = node.getMove();
            }
            alpha = Math.max(alpha, bestValue);
        }
        int validMove = findValidMove(board, bestMove);
        if (validMove != 0) {
            return validMove;
        } else {
            // Handle the case when no valid move is found (e.g., board is full)
            // You may want to return a special value or handle it as appropriate for your
            // game.
            return 0; // Or another suitable value or action
        }
    }

    public int findValidMove(Board board, int move) {
        if (board.isValid(move)) {
            return move; // Found a valid move
        } else {
            int nextMove = move + 1;
            if (nextMove >= board.width) {
                nextMove = 0; // Wrap around to the beginning
            }
            // Ensure that nextMove is within valid bounds
            if (nextMove < 0) {
                nextMove = 0; // Handle case where nextMove becomes negative
            }
            // Recursively try the next move
            return findValidMove(board, nextMove);
        }

    }

    private void generateTree(TreeNode node, int depth, int currentPlayer) {
        if (depth == 0 || Game.winning(node.getBoard().getBoardState(), gameN) != 0) {
            return;
        }

        for (int col = 0; col < node.getBoard().width; col++) {
            if (node.getBoard().isValid(col)) {
                Board newBoard = node.getBoard().getNewBoard(col, currentPlayer);
                TreeNode childNode = new TreeNode(newBoard, col);
                node.addChild(childNode);
                this.player2Id = (playerId == 1) ? 2 : 1;
                generateTree(childNode, depth - 1, currentPlayer);
            }
        }
    }

    private int alphabeta(TreeNode node, int depth, int currentPlayer, int alpha, int beta, boolean isMaximizing) {
        if (depth == 0 || Game.winning(node.getBoard().getBoardState(), gameN) != 0) {
            return heuristic.evaluateBoard(playerId, node.getBoard(), gameN);
        }

        if (isMaximizing) {
            int maxEval = Integer.MIN_VALUE;
            for (TreeNode child : node.getChildren()) {
                currentPlayer = (playerId == 1) ? 2 : 1;
                int eval = alphabeta(child, depth - 1, currentPlayer, alpha, beta, false);
                maxEval = Math.max(maxEval, eval);
                alpha = Math.max(alpha, eval);
                if (beta <= alpha) {
                    break;
                }
            }
            return maxEval;
        } else {
            int minEval = Integer.MAX_VALUE;
            for (TreeNode child : node.getChildren()) {
                currentPlayer = (playerId == 1) ? 2 : 1;
                int eval = alphabeta(child, depth - 1, 3 - currentPlayer, alpha, beta, true);
                minEval = Math.min(minEval, eval);
                beta = Math.min(beta, eval);
                if (beta <= alpha) {
                    break;
                }
            }
            return minEval;
        }
    }
}